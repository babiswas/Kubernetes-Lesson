
https://medium.com/hprog99/a-comprehensive-guide-to-docker-bake-building-bundling-and-shipping-applications-at-scale-77030333586f
https://dzone.com/articles/docker-bake-modern-container-building
https://www.youtube.com/watch?v=QioHwK-kths
Docker Bake file
================
Scalable approach to building docker image.

docker buildx bake -f docker-bake.hcl

Parallel Execution
==================
Bake can build multiple images simultaneously.

1.Groups
2.Runtime Arguments
3.Security and Isolation
4.Better Performance


docker build -t image-tag directory-path
docker run -d -p x1:x2 image-tag

BuildKit Advantage
==================================
Improved Parallelization
Remote Caching
Better Logging and Tracing
Build Secrets and SSH Forwarding


Group---->Collection of targets.
Target---->Specific image build
Context--->Directory from which docker read files.

docker buildx bake -f xyz.hcl executed by buildkit

Configuration types
==================
docker-bake.hcl
docker-bake.yaml
docker-bake.json


group "default" {
  targets = ["service1", "service2"]
}

target "service1" {
  context = "./service1"
  dockerfile = "./service1/Dockerfile"
  tags = ["myorg/service1:latest"]
}



Docker multi stage builds
=========================

# Dockerfile
FROM golang:1.17 as builder
WORKDIR /go/src/app
COPY . .
RUN go build -o myapp

FROM alpine:latest
COPY --from=builder /go/src/app/myapp /usr/local/bin/
CMD ["myapp"]


Multiplatform image
====================

group "default" {
  targets = ["multiarch"]
}

target "multiarch" {
  context = "./"
  dockerfile = "Dockerfile"
  platforms = ["linux/amd64", "linux/arm64"]
  tags = ["myorg/multiarch:latest"]
  push = true
}


target "service2" {
  context = "./service2"
  dockerfile = "./service2/Dockerfile"
  tags = ["myorg/service2:latest"]
}



Enviroment Variables to be enabled
==================================
export DOCKER_BUILDKIT=1
export COMPOSE_DOCKER_CLI_BUILD=1




QEMU Configuration
==================
docker buildx create --use
docker buildx version



variable "VERSION" {
  default = "1.0.0"
}

target "myapp" {
  context = "./"
  dockerfile = "Dockerfile"
  args = {
    VERSION = "${VERSION}"
  }
  tags = ["myorg/myapp:${VERSION}"]
}


docker buildx bake --set myapp.VERSION=2.0.0



group "default" {
  targets = ["backend", "frontend"]
}

target "backend" {
  context = "backend"
  dockerfile = "backend/Dockerfile"
  tags = ["myorg/backend:latest"]
}

target "frontend" {
  context = "frontend"
  dockerfile = "frontend/Dockerfile"
  tags = ["myorg/frontend:latest"]
}




Docker Compose
==============

version: "3.8"
services:
  web:
    build:
      context: ./web
      dockerfile: Dockerfile
    image: myorg/web:latest

  db:
    build:
      context: ./db
      dockerfile: Dockerfile
    image: myorg/db:latest



docker buildx bake



target "my-cached-app" {
  context = "./"
  dockerfile = "Dockerfile"
  tags = ["myorg/my-cached-app:latest"]
  cache-from = ["type=registry,ref=myorg/my-cached-app:cache"]
  cache-to   = ["type=registry,ref=myorg/my-cached-app:cache,mode=max"]
}


BuildKit supports passing secrets at build time without committing them to your final image.

# syntax=docker/dockerfile:1.4
FROM alpine:latest
RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret




Secret file Mounting
====================

# syntax=docker/dockerfile:1.4
FROM alpine:latest
RUN --mount=type=secret,id=mysecret cat /run/secrets/mysecret




target "secret-target" {
  context = "./"
  dockerfile = "Dockerfile"
  secrets = ["id=mysecret,src=./secretfile"]
}


docker buildx bake

Build Arguments
================


target "custom-args" {
  context = "./"
  dockerfile = "Dockerfile"
  args = {
    ENV = "production"
    API_URL = "https://api.example.com"
  }
}



















